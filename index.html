<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<meta name="format-detection" content="telephone=no">
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>World Cup 2026 Dallas Concierge</title>
<style>
    :root{
      --bg:#071022;
      --panel:#0f1b33;
      --panel2:#0b152c;
      --line:rgba(255,255,255,.12);
      --text:#eaf0ff;
      --muted:#b9c7ee;
      --accent:#2ea043;
      --accent2:#1f6feb;
      --warn:#ffcc66;
    }
    body{
      overflow-y: auto;

      margin:0; min-height:100vh; height:auto; display:flex; flex-direction:column;
      font-family: Arial, sans-serif;
      background: radial-gradient(1200px 600px at 20% 10%, #132a5b 0%, var(--bg) 55%);
      color:var(--text);
    }


  function wireNav(){
    const nav = document.getElementById('mobileNav');
    if(!nav) return;
    nav.addEventListener('click', (e)=>{
      const btn = e.target.closest('.mnavBtn');
      if(!btn) return;
      setSection(btn.dataset.msec || 'chat');
    });
    // Default section on mobile (restore last visited)
    if(isMobile() && !document.body.getAttribute('data-msec')){
      let pref = 'home';
      try{ pref = (localStorage.getItem('wc_mobile_section') || 'home'); }catch(_){ }
      setSection(pref);
    }
  }

  // Schedule safe-area padding: ensure pager/bottom-nav never cover last schedule row
  function adjustScheduleBottomPadding(){
    const schedule = document.getElementById('schedule');
    if(!schedule) return;
    const nav = document.getElementById('mobileNav');
    const navH = nav ? nav.getBoundingClientRect().height : 0;
    // add a little extra breathing room
    schedule.style.paddingBottom = (Math.ceil(navH) + 18) + 'px';
  }

  function runAll(){
    wireNav();
    adjustScheduleBottomPadding();
  }

  window.addEventListener('resize', ()=>setTimeout(runAll, 140));
  if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', runAll);
  else runAll();

  // If schedule renders async, call this after render.
  window.adjustScheduleBottomPadding = adjustScheduleBottomPadding;
})();

</script>
<script>
/* Sync hero mini flags with active slide (UI-only) */
(function(){
  const flags = Array.from(document.querySelectorAll('.hero-flag'));
  const slides = Array.from(document.querySelectorAll('.heroSlide'));
  if(!flags.length || !slides.length) return;

  function updateFlags(){
    const active = slides.find(s => s.classList.contains('active'));
    if(!active) return;
    const c = active.getAttribute('data-country');
    flags.forEach(f => f.classList.toggle('active', f.getAttribute('data-country') === c));
  }

  updateFlags();

  const mo = new MutationObserver(updateFlags);
  slides.forEach(s => mo.observe(s, { attributes:true, attributeFilter:['class'] }));
})();
</script>
<script>
/* =======================
   FAN ZONE FEATURES (Backend + Local UX)
   - Country support personalization (localStorage)
   - Live Match-of-the-Day poll (server-persisted)
     * shows live % + counts
     * persists votes (per device client_id)
     * locks automatically at kickoff (server)
     * highlights winner post-match (best-effort)
   - Drink highlight
   - QR poster generator (no external deps)
   ======================= */
(function(){
  try{
    const el = (id)=>document.getElementById(id);

    // ----- Elements -----
    const modal = el("countryModal");
    const countryGrid = el("countryGrid");
    const supporterLabel = el("supporterLabel");
    const supporterFlag = el("supporterFlag");

    const pollCard = el("pollCard");
    const pollModal = el("pollModal");
    const pollList = el("pollListModal") || el("pollList");

    const drinkName = el("drinkName");
    const drinkDesc = el("drinkDesc");

    const qrCard = el("qrCard");
    const qrImg = el("qrImg");
    const qrLink = el("qrLink");

    // Buttons (support both legacy + current Fan Zone markup)
    const btnPickCountry = el("btnPickCountry") || el("fzIconCountry");
    const btnOpenPoll    = el("btnOpenPoll")    || el("fzIconPoll");
    const btnOpenQR      = el("btnOpenQR")      || el("btnSharePoster") || el("fzIconQR");

    // LocalStorage keys
    const LS_SUPPORT = "fz_support_country";
    const LS_CLIENT  = "fz_client_id";
    const LS_VOTE    = "fz_poll_vote"; // {match_id, team}

    // Client id (used for one-vote-per-device on server)
    function getClientId(){
      let id = "";
      try{ id = localStorage.getItem(LS_CLIENT) || ""; }catch(e){}
      if(!id){
        id = (self.crypto && crypto.randomUUID) ? crypto.randomUUID() : ("cid_" + Math.random().toString(16).slice(2) + Date.now());
        try{ localStorage.setItem(LS_CLIENT, id); }catch(e){}
      }
      return id;
    }

    // ----- Countries -----
    let COUNTRIES = [];
    const COUNTRY_META = {
      "United States": { code:"USA", flag:"üá∫üá∏", drink:"Stars & Stripes Spritz", desc:"citrus + mint + sparkle" },
      "Mexico": { code:"MEX", flag:"üá≤üáΩ", drink:"Azteca Paloma", desc:"grapefruit + lime + salt rim" },
      "Canada": { code:"CAN", flag:"üá®üá¶", drink:"Maple Old Fashioned", desc:"bourbon + maple + bitters" },
      "Brazil": { code:"BRA", flag:"üáßüá∑", drink:"Rio Caipirinha", desc:"lime + sugar + cacha√ßa" },
      "Argentina": { code:"ARG", flag:"üá¶üá∑", drink:"La Albiceleste Spritz", desc:"citrus + bubbles" },
      "France": { code:"FRA", flag:"üá´üá∑", drink:"Bleu Royale", desc:"berries + champagne vibe" },
      "England": { code:"ENG", flag:"üè¥", drink:"London Gin Fizz", desc:"gin + lemon + foam" },
      "Spain": { code:"ESP", flag:"üá™üá∏", drink:"Iberian Sangria", desc:"fruit + spice" },
      "Portugal": { code:"POR", flag:"üáµüáπ", drink:"Lisbon Lemonade", desc:"lemon + herb" },
      "Germany": { code:"GER", flag:"üá©üá™", drink:"Bavarian Mule", desc:"ginger + lime" },
      "Japan": { code:"JPN", flag:"üáØüáµ", drink:"Tokyo Highball", desc:"clean + crisp" },
      "Nigeria": { code:"NGA", flag:"üá≥üá¨", drink:"Naija Zobo Cooler", desc:"hibiscus + ginger" },
      "Morocco": { code:"MAR", flag:"üá≤üá¶", drink:"Atlas Mint Tea", desc:"mint + honey" },
      "Senegal": { code:"SEN", flag:"üá∏üá≥", drink:"Dakar Ginger Punch", desc:"ginger + citrus" },
      "Ghana": { code:"GHA", flag:"üá¨üá≠", drink:"Accra Pineapple Twist", desc:"pineapple + lime" }
    };

    function escapeHtml(s){
      return (s || "").toString().replace(/[&<>"']/g, c => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
    }

    function normalizeCountryRows(raw){
      const out = [];
      for(const item of (raw || [])){
        if(!item) continue;
        if(typeof item === "string"){
          const name = item.trim();
          if(!name) continue;
          const meta = COUNTRY_META[name] || {};
          out.push({ name, code: meta.code || name.slice(0,3).toUpperCase(), flag: meta.flag || "üè≥Ô∏è" });
        } else {
          const name = (item.name || item.country || "").trim();
          if(!name) continue;
          const meta = COUNTRY_META[name] || {};
          out.push({
            name,
            code: (item.code || item.fifa_code || item.fifa || "").trim() || meta.code || name.slice(0,3).toUpperCase(),
            flag: (item.flag || "").trim() || meta.flag || "üè≥Ô∏è"
          });
        }
      }
      const seen = new Set();
      return out.filter(c => (seen.has(c.name.toLowerCase()) ? false : (seen.add(c.name.toLowerCase()), true)));
    }

    async function loadQualifiedCountries(){
      // Try both endpoints (per requirement)
      const urls = ["/countries/qualified.json", "/worldcup/qualified.json"];
      for(const u of urls){
        try{
          const res = await fetch(u, {cache:"no-store"});
          if(!res.ok) continue;
          const data = await res.json();
          let list = normalizeCountryRows(data.countries || data.teams || data.qualified || data || []);
          // Safety: prevent huge lists from freezing the UI
          if(list && list.length > 60) list = list.slice(0,60);
          if(list && list.length){
            COUNTRIES = list;
            return;
          }
        }catch(e){}
      }
      // fallback to known meta only (never blocks UI)
      COUNTRIES = normalizeCountryRows(Object.keys(COUNTRY_META));
    }

    // ----- Country support -----
    function getSupport(){
      try{
        const raw = localStorage.getItem(LS_SUPPORT);
        if(raw) return JSON.parse(raw);
      }catch(e){}
      return null;
    }
    function setSupport(country){
      try{ localStorage.setItem(LS_SUPPORT, JSON.stringify(country)); }catch(e){}
    }
    function clearSupport(){
      try{ localStorage.removeItem(LS_SUPPORT); }catch(e){}
    }

    // ----- Supporter theme (flag-tinted, premium) -----
    const SUPPORT_THEME = {
      USA: { a:"rgba(31,111,235,.22)", b:"rgba(214,40,40,.18)", glow:"rgba(245,215,110,.22)" },
      MEX: { a:"rgba(0,104,71,.22)",  b:"rgba(206,17,38,.16)",  glow:"rgba(255,255,255,.16)" },
      CAN: { a:"rgba(213,43,30,.20)", b:"rgba(255,255,255,.14)", glow:"rgba(213,43,30,.18)" },
      BRA: { a:"rgba(0,156,59,.20)",  b:"rgba(255,223,0,.18)",  glow:"rgba(0,156,59,.18)" },
      ARG: { a:"rgba(116,172,223,.22)", b:"rgba(255,255,255,.14)", glow:"rgba(116,172,223,.18)" },
      FRA: { a:"rgba(0,85,164,.22)",  b:"rgba(239,65,53,.16)",  glow:"rgba(245,215,110,.16)" },
      ENG: { a:"rgba(206,17,38,.18)", b:"rgba(255,255,255,.14)", glow:"rgba(206,17,38,.16)" },
      ESP: { a:"rgba(198,12,48,.18)", b:"rgba(255,199,44,.18)", glow:"rgba(255,199,44,.16)" },
      POR: { a:"rgba(0,102,0,.20)",   b:"rgba(255,0,0,.14)",    glow:"rgba(0,102,0,.18)" },
      GER: { a:"rgba(0,0,0,.18)",     b:"rgba(221,0,0,.16)",    glow:"rgba(255,206,0,.16)" },
      JPN: { a:"rgba(188,0,45,.18)",  b:"rgba(255,255,255,.14)", glow:"rgba(188,0,45,.16)" },
      NGA: { a:"rgba(0,135,81,.20)",  b:"rgba(255,255,255,.14)", glow:"rgba(0,135,81,.18)" },
      MAR: { a:"rgba(193,39,45,.18)", b:"rgba(0,98,51,.16)",     glow:"rgba(193,39,45,.16)" },
      SEN: { a:"rgba(0,133,63,.20)",  b:"rgba(252,209,22,.16)",  glow:"rgba(0,133,63,.16)" },
      GHA: { a:"rgba(206,17,38,.18)", b:"rgba(252,209,22,.16)",  glow:"rgba(0,107,63,.14)" }
    };

    function applySupportTheme(c){
      const root = document.documentElement;
      const body = document.body;
      if(!c){
        body.classList.remove("has-support");
        body.removeAttribute("data-support");
        root.style.removeProperty("--supportA");
        root.style.removeProperty("--supportB");
        root.style.removeProperty("--supportGlow");
        return;
      }
      const code = (c.code || c.fifa || c.fifa_code || "").toUpperCase();
      const t = SUPPORT_THEME[code] || null;
      body.classList.add("has-support");
      body.setAttribute("data-support", code || "SET");
      root.style.setProperty("--supportA", t?.a || "rgba(245,215,110,.18)");
      root.style.setProperty("--supportB", t?.b || "rgba(31,111,235,.16)");
      root.style.setProperty("--supportGlow", t?.glow || "rgba(245,215,110,.22)");
    }

    function renderSupporter(){
      const c = getSupport();
      if(supporterLabel) supporterLabel.textContent = c?.name || "Not set";
      if(supporterFlag) supporterFlag.textContent = (c?.flag || "üèÅ");
      applySupportTheme(c);
    }

    function openCountryModal(){
      if(!modal) return;
      modal.classList.add("show");
      // prevent page scroll while modal open
      document.body.style.overflow = "hidden";
    }
    function closeCountryModal(){
      if(!modal) return;
      modal.classList.remove("show");
      document.body.style.overflow = "";
    }

    function buildCountryGrid(){
      if(!countryGrid) return;
      if(!COUNTRIES || !COUNTRIES.length){
        countryGrid.innerHTML = `<div class="fz-muted">Countries unavailable.</div>`;
        return;
      }
      countryGrid.innerHTML = (COUNTRIES || []).map(c => `
        <button class="fz-country" type="button" data-name="${escapeHtml(c.name)}" title="${escapeHtml(c.name)}">
          <span class="fz-flag">${escapeHtml(c.flag)}</span>
          <span>${escapeHtml(c.name)}</span>
        </button>
      `).join("");
      countryGrid.querySelectorAll("[data-name]").forEach(btn=>{
        btn.addEventListener("click", ()=>{
          const name = btn.getAttribute("data-name");
          const c = (COUNTRIES || []).find(x=>x.name===name);
          if(c){
            setSupport(c);
            renderSupporter();
            renderDrink();
            closeCountryModal();
          }
        });
      });
    }

    // ----- Drinks (based on supporter selection) -----
    function renderDrink(){
      const c = getSupport();
      const name = c?.name || "";
      const meta = COUNTRY_META[name] || null;
      if(!drinkName || !drinkDesc) return;
      if(!name){
        drinkName.textContent = "Country-themed drink";
        drinkDesc.textContent = "Pick a country to unlock a themed highlight.";
        return;
      }
      const drink = meta?.drink || (name + " Matchday Mocktail");
      const desc  = meta?.desc || "Ask the bar for a signature special ‚Äî or tap for ideas.";
      drinkName.textContent = drink;
      drinkDesc.textContent = desc;
    }

    // ----- QR poster -----
    function drawQR(text){
  // Real QR code via lightweight external image (no Python deps).
  const img = document.getElementById("qrImg");
  if(!img) return;
  const url = (text || "").trim();
  if(!url){
    img.removeAttribute("src");
    return;
  }
  // qrserver.com is simple and fast; encode data safely.
  const encoded = encodeURIComponent(url);
  img.src = `https://api.qrserver.com/v1/create-qr-code/?size=320x320&margin=4&ecc=H&data=${encoded}`;
  img.alt = "QR code";
}

    function toggleQR(){
      if(!qrCard) return;
      const isOpen = (qrCard.style.display !== "none" && qrCard.style.display !== "");
      qrCard.style.display = isOpen ? "none" : "block";
      if(!isOpen){
        const url = location.origin + location.pathname;
        if(qrLink){
          qrLink.textContent = url;
          qrLink.setAttribute("href", url);
        }
        requestAnimationFrame(()=>drawQR(url));
        // Keep scroll inside right rail (avoid page jump)
        try{
          const rail = document.getElementById("fanZoneRight");
          if(rail && rail.scrollHeight > rail.clientHeight){
            rail.scrollTop = Math.max(0, qrCard.offsetTop - 8);
          }
        }catch(e){}
      }
    }

    // ----- Match poll (backend) -----
    function loadLocalVote(){
      try{
        const raw = localStorage.getItem(LS_VOTE);
        if(!raw) return null;
        return JSON.parse(raw);
      }catch(e){ return null; }
    }
    function saveLocalVote(match_id, team){
      try{ localStorage.setItem(LS_VOTE, JSON.stringify({match_id, team})); }catch(e){}
    }

    function pct(n){ return Number.isFinite(n) ? n : 0; }

    function renderPoll(state){
      if(!pollCard || !pollList) return;

      // Ensure card is open/visible when rendering
      pollCard.style.display = "block";

      const ok = !!(state && state.ok);
      if(!ok){
        pollList.innerHTML = `<div class="fz-muted">Poll unavailable.</div>`;
        return;
      }

      const m = state.match || {};
      const teams = [m.home, m.away].filter(Boolean);
      const counts = state.counts || {};
      const pcts = state.percentages || state.percent || {};
      const locked = !!state.locked;
      const post = !!state.post_match;
      const winner = state.winner || "";
      const sponsor = (state.sponsor_text || "").trim();
      const matchId = m.id || "";

      const localVote = loadLocalVote();
      const votedTeam = (localVote && localVote.match_id === matchId) ? localVote.team : null;

      const headerBits = [];
      if(sponsor) headerBits.push(`<div class="fz-muted" style="margin:6px 0 0 0">${escapeHtml(sponsor)}</div>`);
      if(locked && !post) headerBits.push(`<div class="fz-muted" style="margin:6px 0 0 0">Poll locked at kickoff.</div>`);
      if(post && winner) headerBits.push(`<div class="fz-muted" style="margin:6px 0 0 0">Winner: <b style="color:var(--warn)">${escapeHtml(winner)}</b></div>`);

      const teamRows = teams.map(team=>{
        const c = counts[team] || 0;
        const p = pct(pcts[team] || 0);
        const isWin = post && winner && winner === team;
        const isVoted = votedTeam === team;

        return `
          <div class="fz-vote-row" style="border:1px solid rgba(255,255,255,.12);border-radius:14px;padding:10px;background:rgba(0,0,0,.10)">
            <div style="display:flex;align-items:center;justify-content:space-between;gap:10px">
              <div style="font-weight:900">${escapeHtml(team)} ${isWin ? "üèÜ" : ""}</div>
              <div style="display:flex;align-items:center;gap:8px">
                <div class="fz-muted">${p.toFixed(1)}%</div>
                <div class="fz-muted">‚Ä¢</div>
                <div class="fz-muted">${c}</div>
              </div>
            </div>
            <div style="margin-top:8px;border:1px solid rgba(255,255,255,.10);border-radius:999px;overflow:hidden;height:10px;background:rgba(255,255,255,.04)">
              <div style="height:100%;width:${Math.min(100, Math.max(0,p))}%;background:${isWin ? "rgba(212,175,55,.85)" : "rgba(46,160,67,.75)"}"></div>
            </div>
            <div style="margin-top:10px;display:flex;gap:8px;justify-content:flex-end;flex-wrap:wrap">
              <button class="fz-btn voteBtn" data-team="${escapeHtml(team)}" ${locked ? "disabled" : ""} style="opacity:${locked ? .6 : 1}">
                ${locked ? (isVoted ? "Voted" : "Closed") : (isVoted ? "Voted" : "Vote")}
              </button>
            </div>
          </div>
        `;
      }).join("");

      pollList.innerHTML = `
        ${headerBits.join("")}
        <div style="margin-top:10px;display:grid;gap:10px">
          ${teamRows || `<div class="fz-muted">No match loaded yet.</div>`}
        </div>
      `;

      pollList.querySelectorAll(".voteBtn").forEach(b=>{
        b.addEventListener("click", async ()=>{
          const team = b.getAttribute("data-team") || "";
          if(!team) return;
          await submitVote(team);
        });
      });
    }

    async function fetchPollState(){
      const res = await fetch("/api/poll/state", {cache:"no-store"});
      return await res.json();
    }

    async function submitVote(team){
      try{
        const client_id = getClientId();
        const res = await fetch("/api/poll/vote", {
          method:"POST",
          headers: { "Content-Type":"application/json" },
          body: JSON.stringify({ team, client_id })
        });
        const state = await res.json();
        const mid = state?.match?.id || "";
        if(mid) saveLocalVote(mid, team);
        renderPoll(state);
        setPollLiveUI(state);
      }catch(e){
        // show error but keep UI usable
        if(pollList) pollList.innerHTML = `<div class="fz-muted">Vote failed. Please try again.</div>`;
      }
    }

    // --- Poll modal helpers (premium UX) ---
    function setPollLiveUI(state){
      // "Live" pulse is UI-only: show when voting is open OR we're inside a kickoff window.
      // This keeps the premium pulse testable even when server auto-lock is enabled.
      let live = false;

      const lockedRaw = state && state.locked;
      const locked = (lockedRaw === true) || (typeof lockedRaw === "string" && /locked/i.test(lockedRaw));
      const postMatch = !!(state && state.post_match);

      // If server says voting is open, it's live.
      if(state && locked === false && !postMatch) live = true;

      // Otherwise, consider it "live" within a kickoff time window (best-effort).
      if(!live && state && state.match && !postMatch){
        const dt = state.match.datetime_utc || state.match.kickoff || state.match.datetime || "";
        if(dt){
          const t = Date.parse(dt);
          if(!Number.isNaN(t)){
            const now = Date.now();
            // Live window: 30 min before kickoff -> 2.5 hours after kickoff (typical match length + buffer)
            if(now >= (t - 30*60*1000) && now <= (t + 150*60*1000)) live = true;
          }
        }
      }

      try{
        document.getElementById("btnOpenPoll")?.classList.toggle("is-live", live);
        document.getElementById("fzIconPoll")?.classList.toggle("is-live", live);
      }catch(e){}
    }

    function focusPollModal(){
      if(!pollModal) return;
      // Prefer the first enabled vote button; otherwise fallback to Close.
      const first = pollModal.querySelector(".voteBtn:not([disabled])")
        || pollModal.querySelector("button:not([disabled]), [href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex='-1'])");
      if(first && typeof first.focus === "function"){
        try{ first.focus({preventScroll:true}); }catch(e){ try{ first.focus(); }catch(_e){} }
      }
    }

    let __fzLastFocus = null;

    function openPollModal(){
      // Always show rails when opening
      document.body.classList.remove("fz-hidden");

      __fzLastFocus = document.activeElement;

      if(pollModal){
        pollModal.classList.add("show");
        // prevent page scroll while modal open
        document.body.style.overflow = "hidden";
      } else if(pollCard){
        // Fallback (legacy): inline card
        pollCard.style.display = "block";
      }

      // load live state
      fetchPollState()
        .then((state)=>{
          renderPoll(state);
          setPollLiveUI(state);
          // autofocus after render (kiosk friendly)
          requestAnimationFrame(()=>setTimeout(focusPollModal, 30));
        })
        .catch(()=>{
          renderPoll(null);
          setPollLiveUI(null);
          requestAnimationFrame(()=>setTimeout(focusPollModal, 30));
        });
    }

    function closePollModal(){
      if(pollModal){
        pollModal.classList.remove("show");
        document.body.style.overflow = "";
      }
      if(pollCard) pollCard.style.display = "none";

      // restore focus to where user came from (nice on kiosks/remotes)
      if(__fzLastFocus && typeof __fzLastFocus.focus === "function"){
        try{ __fzLastFocus.focus({preventScroll:true}); }catch(e){ try{ __fzLastFocus.focus(); }catch(_e){} }
      }
      __fzLastFocus = null;
    }

    // Close when clicking backdrop (but not when clicking inside panel)
    if(pollModal){
      pollModal.addEventListener("click", (e)=>{
        if(e.target === pollModal) closePollModal();
      });
    }

    // ----- Wire up -----
    btnPickCountry?.addEventListener("click", (e)=>{ e.preventDefault(); openCountryModal(); });
    el("btnCloseCountry")?.addEventListener("click", (e)=>{ e.preventDefault(); closeCountryModal(); });
    el("btnClearCountry")?.addEventListener("click", (e)=>{ e.preventDefault(); clearSupport(); renderSupporter(); renderDrink(); closeCountryModal(); });

    // Keyboard: ESC closes open Fan Zone modals
    document.addEventListener("keydown", (e)=>{
      if(e.key === "Escape"){
        closeCountryModal();
        closePollModal();
      }
    });


    btnOpenPoll?.addEventListener("click", (e)=>{ e.preventDefault(); openPollModal(); });
    el("btnClosePoll")?.addEventListener("click", (e)=>{ e.preventDefault(); closePollModal(); });

    // Drinks panel is always visible; clicking should just ensure it's in view (within rail)
    el("fzIconDrinks")?.addEventListener("click", ()=>{
      try{
        const rail = document.getElementById("fanZoneRight");
        const card = document.getElementById("drinkCard");
        if(rail && card && rail.scrollHeight > rail.clientHeight){
          rail.scrollTop = Math.max(0, card.offsetTop - 8);
        }
      }catch(e){}
    });

    btnOpenQR?.addEventListener("click", (e)=>{ e.preventDefault(); toggleQR(); });

    // close modal on backdrop click
    modal?.addEventListener("click", (e)=>{
      if(e.target === modal) closeCountryModal();
    });

    // ----- Init (never blocks UI) -----
    renderSupporter();
    renderDrink();

    // Load countries async; rebuild grid when done
    buildCountryGrid(); // initial (may show unavailable/loading)
    loadQualifiedCountries()
      .then(()=>{ buildCountryGrid(); })
      .catch(()=>{ buildCountryGrid(); });

    // Preload poll state quietly (so opening is instant)
    fetchPollState().then(setPollLiveUI).catch(()=>{});

  }catch(e){
    // If anything goes wrong, don't block the rest of the app.
    console && console.warn && console.warn("Fan Zone init failed", e);
  }
})();
</script>
</script>
<script>
/* =======================
   FAN ZONE RAIL BEHAVIOR (UI-only)
   - Auto-hide rails on scroll down; show on scroll up
   - Collapse rails into icon-only mode
   - Glow accent only when Dallas plays (best-effort detection)
   ======================= */
(function(){
  const $ = (id)=>document.getElementById(id);

  // Auto-hide on scroll (desktop only)
  let lastY = window.scrollY || 0;
  let ticking = false;
  function onScroll(){
    if(ticking) return;
    ticking = true;
    requestAnimationFrame(()=>{
      const y = window.scrollY || 0;

      // Always keep rails interactive at the very top of the page
      if(y < 40){
        document.body.classList.remove("fz-hidden");
        lastY = y;
        ticking = false;
        return;
      }

      const goingDown = y > lastY + 10;
      const goingUp   = y < lastY - 10;
      lastY = y;

      // Don‚Äôt auto-hide while the user is interacting with the rails
      const hoverRail = document.body.classList.contains("fz-hovering");

      if(window.innerWidth >= 1200){
        if(!hoverRail && goingDown && y > 120) document.body.classList.add("fz-hidden");
        if(goingUp) document.body.classList.remove("fz-hidden");
      } else {
        document.body.classList.remove("fz-hidden");
      }
      ticking = false;
    });
  }
  window.addEventListener("scroll", onScroll, {passive:true});
  window.addEventListener("resize", ()=>{ if(window.innerWidth < 1200) document.body.classList.remove("fz-hidden"); });
  // If the user moves the mouse into the rails, keep them visible & clickable
  const __fzLeft = document.getElementById("fanZoneLeft");
  const __fzRight = document.getElementById("fanZoneRight");
  [__fzLeft, __fzRight].forEach((rail)=>{
    if(!rail) return;
    rail.addEventListener("mouseenter", ()=>{
      document.body.classList.add("fz-hovering");
      document.body.classList.remove("fz-hidden");
    });
    rail.addEventListener("mouseleave", ()=>{
      document.body.classList.remove("fz-hovering");
    });
  });


  // Collapse toggle
  function toggleCollapse(){ document.body.classList.toggle("fz-collapsed"); }
  $("fzCollapseToggle")?.addEventListener("click", toggleCollapse);
  $("fzCollapseToggle2")?.addEventListener("click", toggleCollapse);

  // Icon-only shortcuts
  $("fzIconCountry")?.addEventListener("click", ()=>document.getElementById("btnPickCountry")?.click());
  $("fzIconPoll")?.addEventListener("click", ()=>document.getElementById("btnOpenPoll")?.click());
  $("fzIconDrinks")?.addEventListener("click", ()=>{
    document.body.classList.remove("fz-hidden");
    if(!document.body.classList.contains("fz-collapsed")){
      document.getElementById("drinkCard")?.scrollIntoView({behavior:"smooth", block:"nearest"});
    }
  });
  $("fzIconQR")?.addEventListener("click", ()=>document.getElementById("btnSharePoster")?.click());

  // Dallas glow detection (best-effort)
  function parsePossibleDate(text){
    const iso = text.match(/\b(20\d{2})-(\d{2})-(\d{2})\b/);
    if(iso) return new Date(Number(iso[1]), Number(iso[2])-1, Number(iso[3]));
    const us = text.match(/\b(\d{1,2})\/(\d{1,2})\/(20\d{2})\b/);
    if(us) return new Date(Number(us[3]), Number(us[1])-1, Number(us[2]));
    return null;
  }

  function hasDallasToday(){
    const today = new Date(); today.setHours(0,0,0,0);

    const candidates = []
      .concat(Array.isArray(window.dallasMatches) ? window.dallasMatches : [])
      .concat(Array.isArray(window.allMatches) ? window.allMatches : [])
      .concat(Array.isArray(window.matches) ? window.matches : []);

    for(const m of candidates){
      const venue = (m?.venue || "").toString().toLowerCase();
      const isDallasVenue = venue.includes("dallas") || venue.includes("arlington") || venue.includes("at&t") || venue.includes("att stadium") || venue.includes("cotton bowl");
      if(!isDallasVenue) continue;

      const raw = (m?.date || m?.datetime || m?.kickoff || m?.start || "").toString();
      const d = raw ? new Date(raw) : null;
      if(d && !isNaN(d.getTime())){
        const dd = new Date(d.getFullYear(), d.getMonth(), d.getDate());
        if(dd.getTime() === today.getTime()) return true;
      }
    }

    const cards = document.querySelectorAll(".match-card.dallas, .match-card");
    const mmdd = `${today.getMonth()+1}/${today.getDate()}`;
    for(const card of cards){
      const t = (card.textContent || "").toLowerCase();
      if(!(t.includes("dallas") || t.includes("arlington") || t.includes("at&t") || t.includes("att stadium") || t.includes("cotton bowl"))) continue;
      if(t.includes("today")) return true;
      if(t.includes(mmdd)) return true;

      const pd = parsePossibleDate(card.textContent || "");
      if(pd){
        pd.setHours(0,0,0,0);
        if(pd.getTime() === today.getTime()) return true;
      }
    }
    return false;
  }

  function refreshDallasGlow(){
    try{
      if(hasDallasToday()) document.body.classList.add("has-dallas-today");
      else document.body.classList.remove("has-dallas-today");
    }catch(e){}
  }

  if(document.readyState === "loading") document.addEventListener("DOMContentLoaded", refreshDallasGlow);
  else refreshDallasGlow();

  const target = document.getElementById("scheduleList") || document.body;
  try{
    const obs = new MutationObserver(()=>{ refreshDallasGlow(); });
    obs.observe(target, {subtree:true, childList:true});
  }catch(e){}
})();
</script>
<script>
/* VIP Table Hold (UI-only)
   IMPORTANT: this is intentionally NOT placed in/under the Dallas schedule panel
   to avoid pager overlap issues. */
(function(){
  const btn = document.getElementById("vipHoldBtn");
  const info = document.getElementById("vipHoldInfoBtn");
  if(info){
    info.addEventListener("click", ()=>{
      alert("VIP Hold = fast-start the reservation flow.\n\nClick ‚ÄòHold a VIP table‚Äô to begin, then answer the questions (name, phone, date, time, party size).");
    });
  }
  if(!btn) return;
  btn.addEventListener("click", ()=>{
    try{
      // Prefer sending a VIP-tagged message first, then ensure reservation flow starts.
      if(typeof sendMessage === "function"){
        sendMessage("VIP table hold ‚Äî reservation");
      } else {
        const msgEl = document.getElementById("msg");
        if(msgEl){ msgEl.value = "VIP table hold ‚Äî reservation"; msgEl.focus(); }
      }
    }catch(e){
      const msgEl = document.getElementById("msg");
      if(msgEl){ msgEl.value = "VIP table hold ‚Äî reservation"; msgEl.focus(); }
    }
  });
})();
</script>

<script>
/* MOBILE MENU TOGGLE (UI-only, safe) */
(function(){
  function isSmall(){ return (window.innerWidth||0) <= 950; }
  // If the newer bottom mobile nav exists, skip legacy injected nav to avoid section/key conflicts.
  if(document.getElementById("mobileNav")) return;

  function setLabel(){
    const t = document.getElementById("menuTitle");
    if(!t) return;
    const base = "Menu";
    if(!isSmall()){ t.textContent = base; return; }
    t.textContent = document.body.classList.contains("menu-expanded") ? (base + " ‚ñæ") : (base + " ‚ñ∏");
  }
  function applyDefault(){
    if(!isSmall()){
      document.body.classList.remove("menu-collapsed","menu-expanded");
      setLabel();
      return;
    }
    const pref = localStorage.getItem("wc_menu_pref") || "collapsed";
    document.body.classList.remove("menu-collapsed","menu-expanded");
    document.body.classList.add(pref === "expanded" ? "menu-expanded" : "menu-collapsed");
    setLabel();
  }
  function toggle(){
    if(!isSmall()) return;
    const nowExpanded = !document.body.classList.contains("menu-expanded");
    document.body.classList.toggle("menu-expanded", nowExpanded);
    document.body.classList.toggle("menu-collapsed", !nowExpanded);
    localStorage.setItem("wc_menu_pref", nowExpanded ? "expanded" : "collapsed");
    setLabel();
  }
  function wire(){
    const t = document.getElementById("menuTitle");
    if(t) t.addEventListener("click", toggle);
  }
  if(document.readyState==="loading"){
    document.addEventListener("DOMContentLoaded", ()=>{ wire(); applyDefault(); });
  }else{
    wire(); applyDefault();
  }
  window.addEventListener("resize", ()=>{ setTimeout(applyDefault, 150); });
})();
</script>


<script>
/* MOBILE SECTION NAV (UI-only, safe)
   Gives phone users full access to desktop features without clutter/overlap. */
(function(){
  // If the newer bottom mobile nav exists, skip legacy injected nav to avoid conflicts.
  if(document.getElementById('mobileNav')){ return; }

  function isSmall(){ return (window.innerWidth||0) <= 950; }

  function ensureScheduleId(){
    const sideTitle = document.getElementById("sideTitle");
    if(sideTitle){
      const card = sideTitle.closest(".card");
      if(card && !card.id) card.id = "scheduleCard";
    }
  }

  function injectNav(){
    if(!isSmall()) return;
    const hero = document.getElementById("heroBanner") || document.querySelector(".hero");
    if(!hero) return;

    // Avoid duplicates
    if(document.getElementById("mnav")) return;

    const nav = document.createElement("div");
    nav.className = "mnav";
    nav.id = "mnav";
    nav.innerHTML = `
      <button class="mnav-btn" data-sec="home">Home</button>
      <button class="mnav-btn" data-sec="chat">Chat</button>
      <button class="mnav-btn" data-sec="fanzone">Fan Zone</button>
      <button class="mnav-btn" data-sec="vip">VIP</button>
      <button class="mnav-btn" data-sec="extras">Extras</button>
      <button class="mnav-btn" data-sec="schedule">Schedule</button>
      <button class="mnav-btn" data-sec="menu">Menu</button>
    `;

    hero.insertAdjacentElement("afterend", nav);

    nav.addEventListener("click", (e) => {
      const b = e.target.closest("button[data-sec]");
      if(!b) return;
      const sec = b.getAttribute("data-sec");
      setSection(sec, true);
    });
  }

  function setSection(sec, persist){
  if(sec === "home"){
      // Home = default experience (chat) + clear any persisted section
      try{ localStorage.removeItem("wc_mobile_section"); }catch(e){}
      sec = "chat";
      document.body.removeAttribute("data-msec");
    }
    if(!isSmall()) return;
    document.body.setAttribute("data-msec", sec || "chat");
    // button states
    const nav = document.getElementById("mnav");
    if(nav){
      nav.querySelectorAll(".mnav-btn").forEach(btn => {
        btn.classList.toggle("on", btn.getAttribute("data-sec") === sec);
      });
    }
    if(persist){
      try{ localStorage.setItem("wc_mobile_section", sec); }catch(e){}
    }

    // When showing chat, focus input for quick use
    if(sec === "chat"){
      try{
        const t = document.getElementById("msg");
        if(t){ t.focus({preventScroll:true}); }
      }catch(e){}
    }

    // Scroll to top of section (keeps premium feel)
    try{ window.scrollTo({top: 0, behavior: "smooth"}); }catch(e){}
  }

  
// Back gesture: if on another section and user hits browser back (popstate), return to chat without leaving
window.addEventListener("popstate", () => {
  try{
    if(isSmall()){
      setSection("chat", true);
    }
  }catch(e){}
});

function apply(){
    ensureScheduleId();
    if(isSmall()){
      injectNav();
      const pref = (localStorage.getItem("wc_mobile_section") || "chat");
      setSection(pref, false);
    }else{
      // desktop: remove attribute so everything shows
      document.body.removeAttribute("data-msec");
      const nav = document.getElementById("mnav");
      if(nav) nav.remove();
    }
  }

  if(document.readyState==="loading"){
    document.addEventListener("DOMContentLoaded", apply);
  }else{
    apply();
  }

  let t=null;
  window.addEventListener("resize", () => {
    clearTimeout(t);
    t = setTimeout(apply, 160);
  });
})();
</script>


<script>
/* Hero shrink-on-scroll (desktop & mobile) */
(function(){
  const banner = document.getElementById("heroBanner") || document.querySelector("#heroBanner, .hero");
  if(!banner) return;

  let ticking = false;
  function apply(){
    ticking = false;
    const shrink = (window.scrollY || document.documentElement.scrollTop || 0) > 12;
    banner.classList.toggle("is-shrunk", shrink);
  }
  function onScroll(){
    if(ticking) return;
    ticking = true;
    window.requestAnimationFrame(apply);
  }
  window.addEventListener("scroll", onScroll, {passive:true});
  window.addEventListener("resize", apply, {passive:true});
  apply();
})();
</script>


<script>
/* Mobile nav wiring (v3) */
(function(){
  const nav = document.getElementById('mobileNav');
  if(!nav) return;

  function handle(e){
    const btn = e.target && e.target.closest ? e.target.closest('.mnavBtn') : null;
    if(!btn) return;

    const sec = btn.getAttribute('data-msec') || 'home';

    // Switch section
    if(typeof window.setSection === 'function') window.setSection(sec);

    // Active state
    nav.querySelectorAll('.mnavBtn').forEach(b=>b.classList.toggle('active', b===btn));

    // Critical mobile UX: focus chat input *synchronously* inside the user gesture
    if(sec === 'chat'){
      try{ __focusChatInput(); }catch(_){}
      try{ requestAnimationFrame(()=>{ try{ __focusChatInput(); }catch(_2){} }); }catch(_){}
    }
  }

  // Use touch/pointer to keep focus allowed on iOS Safari
  nav.addEventListener('pointerdown', (e)=>{
    // Let mouse clicks behave normally (desktop testing)
    if(e && e.pointerType === 'mouse') return;
    handle(e);
  }, {passive:false});

  nav.addEventListener('touchstart', (e)=>{ handle(e); }, {passive:false});
  nav.addEventListener('click', (e)=>{ handle(e); });
})();
</script>


<script>
/* === PHASE 2: DVH FIX (AUTO-INSERTED) === */
(() => {
  // Stabilize ‚Äú100vh‚Äù on iOS address-bar collapse/expand.
  const setDvh = () => {
    document.documentElement.style.setProperty('--dvh', `${window.innerHeight * 0.01}px`);
  };
  setDvh();
  window.addEventListener('resize', setDvh, { passive: true });
  window.addEventListener('orientationchange', setDvh, { passive: true });
})();
</script>


<script>
/* === PHASE 4: INTERACTION ENGINE (AUTO-INSERTED) === */
(() => {
  const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;

  // 1) Add ‚Äútactile‚Äù press + ripple on tap for buttons/interactive elements
  const pressSelector = 'button, a.btn, .btn, .pill, .chip, .langbtn, .segBtn, .navBtn, .tabBtn, [role="button"]';

  const ensurePressClass = (el) => {
    if (!el.classList.contains('lux-press')) el.classList.add('lux-press');
  };

  const setRippleVars = (el, ev) => {
    try {
      const r = el.getBoundingClientRect();
      const x = ((ev.clientX - r.left) / Math.max(1, r.width)) * 100;
      const y = ((ev.clientY - r.top) / Math.max(1, r.height)) * 100;
      el.style.setProperty('--lux-rx', `${x.toFixed(2)}%`);
      el.style.setProperty('--lux-ry', `${y.toFixed(2)}%`);
    } catch (_) {}
  };

  document.addEventListener('pointerdown', (ev) => {
    const t = ev.target && ev.target.closest ? ev.target.closest(pressSelector) : null;
    if (!t) return;
    ensurePressClass(t);
    if (!prefersReduced) setRippleVars(t, ev);
    t.classList.add('is-pressing');
  }, { passive: true });

  const clearPress = (ev) => {
    const t = ev.target && ev.target.closest ? ev.target.closest(pressSelector) : null;
    if (!t) return;
    t.classList.remove('is-pressing');
  };

  document.addEventListener('pointerup', clearPress, { passive: true });
  document.addEventListener('pointercancel', clearPress, { passive: true });
  document.addEventListener('pointerleave', clearPress, { passive: true });

  // 2) Smart image loading defaults (keeps hero crisp; lazy-loads non-hero images)
  try {
    const imgs = Array.from(document.querySelectorAll('img'));
    imgs.forEach(img => {
      const inHero = img.closest && (img.closest('.hero') || img.closest('.heroSlide'));
      if (!inHero) img.loading = img.loading || 'lazy';
      img.decoding = img.decoding || 'async';
    });
  } catch (_) {}

  // 3) Passive listeners for scroll/touch to keep mobile smooth
  //    (No behavioral change; performance hint only)
  const passiveEvents = ['touchstart','touchmove','wheel'];
  passiveEvents.forEach(evt => {
    window.addEventListener(evt, () => {}, { passive: true });
  });

})();
</script>


<script>
/* === PHASE 5: DEVICE CLASSIFIER (AUTO-INSERTED) === */
(() => {
  const ua = navigator.userAgent || "";
  const isIOS = /iPhone|iPad|iPod/i.test(ua) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
  const isAndroid = /Android/i.test(ua);
  const isSafari = /^((?!chrome|android).)*safari/i.test(ua);

  const root = document.documentElement;
  if (isIOS) root.classList.add('is-ios');
  if (isAndroid) root.classList.add('is-android');
  if (isSafari) root.classList.add('is-safari');

  // Consistent tap delay handling (modern browsers ignore, harmless otherwise)
  root.style.touchAction = 'manipulation';
})();
</script>


<script>
/* === PHASE 6: PERFORMANCE + QA MATRIX (AUTO-INSERTED) === */
(() => {
  const q = new URLSearchParams(location.search);
  // --- 1) Ultra-premium performance scheduling (no behavior changes) ---
  const onIdle = (fn, timeout=800) => {
    if ('requestIdleCallback' in window) {
      requestIdleCallback(fn, { timeout });
    } else {
      setTimeout(fn, Math.min(timeout, 250));
    }
  };

  // Intersection-based reveal (smooth + cheap)
  onIdle(() => {
    try {
      const els = Array.from(document.querySelectorAll('.lux-reveal'));
      if (!els.length || !('IntersectionObserver' in window)) {
        els.forEach(e => e.classList.add('in-view'));
        return;
      }
      const io = new IntersectionObserver((entries) => {
        entries.forEach(ent => {
          if (ent.isIntersecting) {
            ent.target.classList.add('in-view');
            io.unobserve(ent.target);
          }
        });
      }, { root: null, threshold: 0.12 });
      els.forEach(e => io.observe(e));
    } catch (_) {}
  }, 600);

  // --- 2) Micro-perf marks (for real-device QA) ---
  try {
    performance.mark('lux_boot_start');
    window.addEventListener('load', () => {
      try {
        performance.mark('lux_load');
        performance.measure('lux_boot_to_load', 'lux_boot_start', 'lux_load');
      } catch(_) {}
    }, { once: true });
  } catch(_) {}

  // --- 3) Per-device QA matrix (only when ?qa=1) ---

  const showToast = (main, sub="", btnText="", onBtn=null) => {
    const t = ensureToast();
    t.style.display = 'block';
    const m = t.querySelector('#luxToastMain');
    const s = t.querySelector('#luxToastSub');
    const b = t.querySelector('#luxToastBtn');
    if (m) m.textContent = main || "";
    if (s) s.textContent = sub || "";
    if (btnText && b) {
      b.textContent = btnText;
      b.style.display = 'inline-flex';
      b.onclick = () => { try { onBtn && onBtn(); } catch(_) {} };
    } else if (b) {
      b.style.display = 'none';
      b.onclick = null;
    }
    if (!prefersReduced) {
      t.style.transform = 'translateY(6px)';
      t.style.opacity = '0.001';
      requestAnimationFrame(() => {
        t.style.transition = 'opacity .22s ease, transform .28s ease';
        t.style.opacity = '1';
        t.style.transform = 'translateY(0)';
      });
    }
  };

  const hideToast = () => {
    const t = document.getElementById('luxToast');
    if (!t) return;
    if (prefersReduced) { t.style.display = 'none'; return; }
    t.style.transition = 'opacity .18s ease, transform .18s ease';
    t.style.opacity = '0';
    t.style.transform = 'translateY(6px)';
    setTimeout(() => { t.style.display = 'none'; }, 180);
  };

  // Offline / online feedback
  const updateOnline = () => {
    if (navigator.onLine === false) {
      showToast('You‚Äôre offline', 'We‚Äôll reconnect automatically when network returns.');
    } else {
      hideToast();
    }
  };
  window.addEventListener('online', updateOnline, { passive: true });
  window.addEventListener('offline', updateOnline, { passive: true });
  setTimeout(updateOnline, 300);

  // Fetch reliability: timeout + single retry for GET to read-only endpoints.
  const originalFetch = window.fetch ? window.fetch.bind(window) : null;
  if (!originalFetch) return;

  const withTimeout = (promise, ms, controller) => {
    let t;
    const timeout = new Promise((_, rej) => {
      t = setTimeout(() => {
        try { controller && controller.abort(); } catch(_) {}
        rej(new Error('Timeout'));
      }, ms);
    });
    return Promise.race([promise.finally(() => clearTimeout(t)), timeout]);
  };

  const shouldGuard = (input, init) => {
    const method = (init && init.method) ? String(init.method).toUpperCase() : 'GET';
    if (method !== 'GET') return false;
    const url = (typeof input === 'string') ? input : (input && input.url) ? input.url : '';
    return /(\.json($|\?)|\/api\/|\/worldcup\/|\/countries\/)/i.test(url);
  };

  window.fetch = async (input, init) => {
    if (!shouldGuard(input, init)) return originalFetch(input, init);

    const controller = ('AbortController' in window) ? new AbortController() : null;
    const mergedInit = controller ? { ...(init||{}), signal: controller.signal } : (init||{});
    try {
      const res = await withTimeout(originalFetch(input, mergedInit), 9000, controller);
      if (!res || (res.status >= 500 && res.status <= 599)) throw new Error('HTTP ' + (res ? res.status : 'ERR'));
      return res;
    } catch (e) {
      // retry once
      try {
        await new Promise(r => setTimeout(r, 450));
        const controller2 = ('AbortController' in window) ? new AbortController() : null;
        const merged2 = controller2 ? { ...(init||{}), signal: controller2.signal } : (init||{});
        const res2 = await withTimeout(originalFetch(input, merged2), 9000, controller2);
        if (!res2 || (res2.status >= 500 && res2.status <= 599)) throw new Error('HTTP ' + (res2 ? res2.status : 'ERR'));
        hideToast();
        return res2;
      } catch (e2) {
        showToast('Network is slow right now', 'Pull to refresh or tap Retry.', 'Retry', () => location.reload());
        throw e2;
      }
    }
  };

  // Global JS error surface (premium + QA-friendly)
  window.addEventListener('error', (ev) => {
    try {
      const msg = (ev && ev.message) ? ev.message : 'Unexpected error';
      showToast('Something went wrong', msg);
    } catch(_) {}
  });
  window.addEventListener('unhandledrejection', (ev) => {
    try {
      const msg = (ev && ev.reason && (ev.reason.message || String(ev.reason))) ? (ev.reason.message || String(ev.reason)) : 'Promise error';
      showToast('Something went wrong', msg);
    } catch(_) {}
  });
})();

/* === MICRO-POLISH (SAFE) === */
(function(){
  function updateNavSafe(){
    const nav = document.querySelector('.mnav');
    if(!nav) return;
    const h = Math.ceil(nav.getBoundingClientRect().height || 0);
    document.documentElement.style.setProperty('--mnav-h', h + 'px');
  }

  // Run now + after layout settles
  const raf2 = (fn)=>requestAnimationFrame(()=>requestAnimationFrame(fn));
  raf2(updateNavSafe);

  window.addEventListener('resize', updateNavSafe, {passive:true});
  window.addEventListener('orientationchange', ()=>raf2(updateNavSafe), {passive:true});

  // If nav is inserted later, observe once and update
  const mo = new MutationObserver(()=>{ updateNavSafe(); });
  mo.observe(document.documentElement, { childList:true, subtree:true });

  // Tiny press feedback on primary interactive elements (CSS handles most; this is a fallback for custom controls)
  document.addEventListener('pointerdown', (e)=>{
    const el = e.target && e.target.closest ? e.target.closest('.mnav-btn, button, .chip, .pill, .seg button, .btn') : null;
    if(!el) return;
    el.classList.add('is-pressed');
    raf2(()=>el.classList.remove('is-pressed'));
  }, {passive:true});
})();

</script>

</body>
</html>